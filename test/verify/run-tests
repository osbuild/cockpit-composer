#!/usr/bin/python3

import os
import string
import subprocess
import sys
import unittest
import dataclasses
import time
import socket
import tempfile
import pathlib

import importlib.machinery
import importlib.util

import parent
import testlib
import testvm

# avoid .pyc
sys.dont_write_bytecode = True
# immediately dump logs to the stream instead of being buffered
os.environ['PYTHONUNBUFFERED'] = '1'

# a test data class
@dataclasses.dataclass
class Test:
    test_id: int
    command: list
    timeout: int
    process: subprocess.Popen = None
    output: bytes = b""


# test section
def test_name(test):
    return "{0} {1} {2}".format(test.test_id, test.command[0], test.command[-1])


def print_test(test, print_tap=True):
    for line in test.output.splitlines(keepends=True):
        sys.stdout.buffer.write(line)
    sys.stdout.flush()

    if not print_tap:
        return

    if test.process.returncode == 0:
        print("ok " + test_name(test))
    elif test.process.returncode == 77 or b"# SKIP " in test.output:
        # If the test was skipped, add the last line (which contains the reason
        # for the skip) to the result
        print("ok {0} {1}".format(test_name(test),
              test.output.splitlines()[-1].strip().decode()
              if test.process.returncode == 77 else ""))
    else:
        print("not ok " + test_name(test))
    sys.stdout.flush()


def check_valid(filename):
    name = filename.name
    allowed = string.ascii_letters + string.digits + '-_'
    if not all(c in allowed for c in name):
        return None
    return name.replace("-", "_")


def build_command(filename, test, opts):
    cmd = [filename]
    if opts.trace:
        cmd.append("-t")
    if opts.verbosity:
        cmd.append("-v")
    if opts.list:
        cmd.append("-l")
    cmd.append(test)
    return cmd


def run(opts):
    # Build the list of tests we'll run serially
    test_loader = unittest.TestLoader()
    serial_tests = []
    test_id = 1
    result = 0
    start_time = time.time()
    serial_tests_duration = 0

    for filename in pathlib.Path(__file__).parent.glob("check-*"):
        name = check_valid(filename)
        if not name or not filename.is_file():
            continue
        loader = importlib.machinery.SourceFileLoader(name, str(filename))
        module = importlib.util.module_from_spec(
            importlib.util.spec_from_loader(loader.name, loader))
        loader.exec_module(module)
        for test_suite in test_loader.loadTestsFromModule(module):
            for test in test_suite:
                test_method = getattr(test.__class__, test._testMethodName)
                test_str = "{0}.{1}".format(test.__class__.__name__, test._testMethodName)
                # most tests should take much less than 10mins(default);
                # longer tests can be annotated with @timeout(seconds)
                # check the test function first, fall back to the class timeout
                test_timeout = getattr(test_method, "__timeout", getattr(test, "__timeout", 600))
                if opts.tests and not any([t in test_str for t in opts.tests]):
                    continue
                test = Test(test_id, build_command(filename, test_str, opts), test_timeout)
                serial_tests.append(test)
                test_id += 1

    print("1..{0}".format(len(serial_tests)))
    sys.stdout.flush()

    for test in serial_tests:
        test.command.insert(-2, "--machine")
        test.command.insert(-2, opts.machine)
        test.command.insert(-2, "--browser")
        test.command.insert(-2, opts.browser)

    running_test = None
    serial_tests_len = len(serial_tests)
    while serial_tests or running_test is not None:
        if running_test is None:
            made_progress = False
            test = serial_tests.pop(0)
            serial_test_start = time.time()
            made_progress = True
            test.outfile = tempfile.TemporaryFile()
            test.process = subprocess.Popen(["timeout", str(test.timeout)] + test.command,
                                            stdout=test.outfile,
                                            stderr=subprocess.STDOUT)
            running_test = test

        poll_result = running_test.process.poll()
        if poll_result is not None:
            made_progress = True
            test.outfile.seek(0)
            test.output = test.outfile.read()
            test.outfile.close()
            running_test = None
            print_test(test)
            result += test.process.returncode

            serial_tests_duration += (time.time() - serial_test_start)

        # Sleep if we didn't make progress
        if not made_progress:
            time.sleep(0.5)

    duration = int(time.time() - start_time)
    hostname = socket.gethostname().split(".")[0]
    details = "[{0}s on {1}, {2} serial tests took {3}s]".format(duration,
                                                                 hostname,
                                                                 serial_tests_len,
                                                                 int(serial_tests_duration))
    if result > 0:
        print("# {0} TESTS FAILED {1}".format(result, details))
    else:
        print("# TESTS PASSED {0}".format(details))

    return result


# machine secion
def new_vm(verbose, cpu, memory, image):
    network = testvm.VirtNetwork(image=image)
    machine = testvm.VirtMachine(verbose=verbose, image=image,
                                 networking=network.host(),
                                 memory_mb=memory, cpus=cpu)
    machine.start()
    return machine


def wait_for_composer_running(machine):
    WAIT_COMPOSER_RUNNING = """#!/bin/sh
until curl --unix-socket /run/weldr/api.socket \
    http://localhost/api/status | grep '"db_supported": *true'; do
sleep 1;
done;
"""
    with testvm.Timeout(seconds=600,
                        error_message="Timeout while waiting for osbuild-composer to start"):
        machine.execute(script=WAIT_COMPOSER_RUNNING)


def main():
    parser = testlib.arg_parser()
    parser.add_argument('-M', '--memory', type=int, default=4096,
                        help='Memory (in MiB) of the target machine')
    parser.add_argument('-C', '--cpu', type=int, default=2,
                        help='Number of cpus in the target machine')
    parser.add_argument("--machine", type=str,
                        help="format: <ssh_address>:<ssh_port>")
    parser.add_argument("--browser", type=str,
                        help="format: <web_address>:<web_port>")
    opts = parser.parse_args()

    image = testvm.DEFAULT_IMAGE
    test_browser = os.environ.get("TEST_BROWSER", "chromium")

    # Tell any subprocesses what we are testing
    os.environ["TEST_BROWSER"] = test_browser
    testvm.DEFAULT_IMAGE = image
    os.environ["TEST_OS"] = image

    if opts.machine is None:
        test_machine = new_vm(verbose=opts.trace,
                              cpu=opts.cpu,
                              memory=opts.memory,
                              image=image)
        if opts.trace:
            print("Starting a new machine {}".format(test_machine.label))
    else:
        test_machine = testvm.Machine(address=opts.machine,
                                      image=image,
                                      verbose=opts.trace,
                                      browser=opts.browser)
        if opts.trace:
            print("Use a started machine {}".format(test_machine.label))

    test_machine.wait_for_cockpit_running()
    wait_for_composer_running(test_machine)

    # used by run()
    opts.machine = "{0}:{1}".format(test_machine.ssh_address, test_machine.ssh_port)
    opts.browser = "{0}:{1}".format(test_machine.web_address, test_machine.web_port)

    # Let's go
    return_code = run(opts)

    # Report code coverage result to codecov.io
    codecov_token_file = pathlib.Path.home() / ".config" / "codecov-token"
    if codecov_token_file.is_file() and return_code == 0:
        token = codecov_token_file.read_text().replace("\n", "")
        os.environ["CODECOV_TOKEN"] = token
        subprocess.run("curl -s https://codecov.io/bash | bash", shell=True)

    return return_code


if __name__ == '__main__':
    sys.exit(main())
